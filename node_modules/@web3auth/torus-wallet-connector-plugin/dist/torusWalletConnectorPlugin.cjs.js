/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "TorusWalletConnectorPlugin": () => (/* reexport */ TorusWalletConnectorPlugin)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/torus-embed"
const torus_embed_namespaceObject = require("@toruslabs/torus-embed");
var torus_embed_default = /*#__PURE__*/__webpack_require__.n(torus_embed_namespaceObject);
;// CONCATENATED MODULE: external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// CONCATENATED MODULE: external "@web3auth/base-plugin"
const base_plugin_namespaceObject = require("@web3auth/base-plugin");
;// CONCATENATED MODULE: external "loglevel"
const external_loglevel_namespaceObject = require("loglevel");
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_namespaceObject);
;// CONCATENATED MODULE: ./src/errors.ts


class TorusWalletPluginError extends base_namespaceObject.Web3AuthError {
  constructor(code, message) {
    // takes care of stack and proto
    super(code, message);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "TorusWalletPluginError"
    });
  }
  static fromCode(code) {
    let extraMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return new TorusWalletPluginError(code, `${TorusWalletPluginError.messages[code]}${extraMessage}`);
  }
  static notInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5210, extraMessage);
  }
  static unsupportedAdapter() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5211, extraMessage);
  }
  static providerRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5212, extraMessage);
  }
  static web3authRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5213, extraMessage);
  }
  static web3AuthNotConnected() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5214, extraMessage);
  }
  static userInfoRequired() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5215, extraMessage);
  }
  static alreadyInitialized() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5216, extraMessage);
  }
  static torusWalletNotSet() {
    let extraMessage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    return TorusWalletPluginError.fromCode(5217, extraMessage);
  }
}
defineProperty_default()(TorusWalletPluginError, "messages", {
  5210: "Torus Wallet Plugin is not initialized",
  5211: "Web3Auth is connected to unsupported adapter. Torus wallet connector plugin requires web3auth connected to openlogin adapter.",
  5212: "Provider is required..",
  5213: "Web3Auth instance is required while initialization.",
  5214: "Web3Auth is not connected.",
  5215: "UserInfo is required.",
  5216: "Plugin is already initialized",
  5217: "Torus wallet instance is not set."
});
;// CONCATENATED MODULE: ./src/plugin.ts

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





class TorusWalletConnectorPlugin {
  constructor(options) {
    defineProperty_default()(this, "name", "TORUS_WALLET_CONNECTOR_PLUGIN");
    defineProperty_default()(this, "SUPPORTED_ADAPTERS", [base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN]);
    defineProperty_default()(this, "pluginNamespace", base_plugin_namespaceObject.PLUGIN_NAMESPACES.EIP155);
    defineProperty_default()(this, "torusWalletInstance", void 0);
    defineProperty_default()(this, "provider", null);
    defineProperty_default()(this, "web3auth", null);
    defineProperty_default()(this, "userInfo", null);
    defineProperty_default()(this, "isInitialized", false);
    defineProperty_default()(this, "walletInitOptions", null);
    const {
      torusWalletOpts = {},
      walletInitOptions
    } = options;
    const whiteLabel = walletInitOptions === null || walletInitOptions === void 0 ? void 0 : walletInitOptions.whiteLabel;
    if (!whiteLabel) throw new Error("whiteLabel is required");
    const {
      logoDark,
      logoLight
    } = whiteLabel;
    if (!logoDark || !logoLight) throw new Error("logoDark and logoLight are required in whiteLabel config");
    this.torusWalletInstance = new (torus_embed_default())(torusWalletOpts);
    this.walletInitOptions = walletInitOptions;
  }
  get proxyProvider() {
    return this.torusWalletInstance.isLoggedIn ? this.torusWalletInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth) {
    if (this.isInitialized) return;
    if (!web3auth) throw TorusWalletPluginError.web3authRequired();
    if (web3auth.provider && web3auth.connectedAdapterName !== base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    // Not connected yet to openlogin
    if (web3auth.provider) {
      this.provider = web3auth.provider;
      this.userInfo = await web3auth.getUserInfo();
    }
    this.web3auth = web3auth;
    this.subscribeToWeb3AuthNoModalEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    const network = _objectSpread(_objectSpread({}, web3auth.coreOptions.chainConfig), {}, {
      networkName: connectedChainConfig.displayName,
      host: connectedChainConfig.rpcTarget,
      chainId: parseInt(connectedChainConfig.chainId, 16)
    });
    await this.torusWalletInstance.init(_objectSpread(_objectSpread({}, this.walletInitOptions || {}), {}, {
      network,
      showTorusButton: false
    }));
    this.isInitialized = true;
  }
  async initWithProvider(provider, userInfo) {
    if (this.isInitialized) return;
    if (!userInfo) throw TorusWalletPluginError.userInfoRequired();
    if (!provider) throw TorusWalletPluginError.providerRequired();
    this.provider = provider;
    this.userInfo = userInfo;
    await this.torusWalletInstance.init(this.walletInitOptions || {});
    this.isInitialized = true;
  }
  async connect() {
    // if web3auth is being used and connected to unsupported adapter throw error
    if (this.web3auth && this.web3auth.connectedAdapterName !== base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    if (!this.isInitialized) throw TorusWalletPluginError.notInitialized();
    // Not connected yet to openlogin
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
        this.userInfo = await this.web3auth.getUserInfo();
      } else if (this.web3auth) {
        throw TorusWalletPluginError.web3AuthNotConnected();
      } else {
        throw TorusWalletPluginError.providerRequired();
      }
    }
    let privateKey;
    try {
      // it should throw if provider doesn't support `eth_private_key` function
      privateKey = await this.provider.request({
        method: "eth_private_key"
      });
    } catch (error) {
      external_loglevel_default().warn("unsupported method", error, TorusWalletPluginError.unsupportedAdapter());
      if ((error === null || error === void 0 ? void 0 : error.code) === -32004) throw TorusWalletPluginError.unsupportedAdapter();
      throw error;
    }
    if (!privateKey) throw TorusWalletPluginError.web3AuthNotConnected();
    try {
      var _this$userInfo;
      await this.torusWalletInstance.loginWithPrivateKey({
        privateKey,
        userInfo: _objectSpread(_objectSpread({}, this.userInfo), {}, {
          typeOfLogin: (_this$userInfo = this.userInfo) === null || _this$userInfo === void 0 ? void 0 : _this$userInfo.typeOfLogin // openlogin's login type is subset of torus embed, so it is safe to cast.
        })
      });

      this.torusWalletInstance.showTorusButton();
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
    } catch (error) {
      external_loglevel_default().error(error);
    }
  }
  async showWalletConnectScanner() {
    if (!this.torusWalletInstance.isLoggedIn) throw TorusWalletPluginError.web3AuthNotConnected();
    await this.torusWalletInstance.showWalletConnectScanner();
  }
  async initiateTopup(provider, params) {
    if (!this.torusWalletInstance.isLoggedIn) throw TorusWalletPluginError.web3AuthNotConnected();
    await this.torusWalletInstance.initiateTopup(provider, params);
  }
  async disconnect() {
    var _this$web3auth2;
    // if web3auth is being used and connected to unsupported adapter throw error
    if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.connectedAdapterName) !== base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN) throw TorusWalletPluginError.unsupportedAdapter();
    if (this.torusWalletInstance.isLoggedIn) {
      await this.torusWalletInstance.logout();
    } else {
      throw new Error("Torus Wallet plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$torusWalletInst,
      _this = this;
    (_this$torusWalletInst = this.torusWalletInstance) === null || _this$torusWalletInst === void 0 ? void 0 : _this$torusWalletInst.provider.on("accountsChanged", function () {
      let accounts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (accounts.length === 0) {
        var _this$web3auth3, _this$web3auth4;
        _this.torusWalletInstance.hideTorusButton();
        if (((_this$web3auth3 = _this.web3auth) === null || _this$web3auth3 === void 0 ? void 0 : _this$web3auth3.status) === base_namespaceObject.ADAPTER_STATUS.CONNECTED) (_this$web3auth4 = _this.web3auth) === null || _this$web3auth4 === void 0 ? void 0 : _this$web3auth4.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    var _this2 = this;
    provider.on("accountsChanged", function () {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        accounts: []
      };
      _this2.setSelectedAddress(data.accounts[0]);
    });
    provider.on("chainChanged", data => {
      this.setChainID(parseInt(data.chainId, 16));
    });
    provider.on("disconnect", () => {
      this.torusWalletInstance.hideTorusButton();
    });
    provider.on("connect", () => {
      this.torusWalletInstance.showTorusButton();
    });
  }
  subscribeToWeb3AuthNoModalEvents(web3Auth) {
    web3Auth.on(base_namespaceObject.ADAPTER_EVENTS.CONNECTED, async () => {
      if (web3Auth.connectedAdapterName !== base_namespaceObject.WALLET_ADAPTERS.OPENLOGIN) {
        external_loglevel_default().warn(`${web3Auth.connectedAdapterName} is not compatible with torus wallet connector plugin`);
        return;
      }
      this.provider = web3Auth.provider;
      this.userInfo = await web3Auth.getUserInfo();
      if (!this.provider) throw TorusWalletPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(base_namespaceObject.ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      this.userInfo = null;
      if (this.torusWalletInstance.isLoggedIn) {
        await this.torusWalletInstance.logout();
      }
      this.torusWalletInstance.hideTorusButton();
    });
  }
  async sessionConfig() {
    if (!this.provider) throw TorusWalletPluginError.web3AuthNotConnected();
    const [accounts, chainId, privateKey, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_private_key"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts: accounts,
      privateKey: privateKey,
      chainConfig: chainConfig
    };
  }
  async setSelectedAddress(address) {
    var _sessionConfig$accoun;
    if (!this.torusWalletInstance.isLoggedIn || !this.userInfo) throw TorusWalletPluginError.web3AuthNotConnected();
    const sessionConfig = await this.sessionConfig();
    if (address !== ((_sessionConfig$accoun = sessionConfig.accounts) === null || _sessionConfig$accoun === void 0 ? void 0 : _sessionConfig$accoun[0])) {
      var _this$userInfo2;
      await this.torusWalletInstance.loginWithPrivateKey({
        privateKey: sessionConfig.privateKey,
        userInfo: _objectSpread(_objectSpread({}, this.userInfo), {}, {
          typeOfLogin: (_this$userInfo2 = this.userInfo) === null || _this$userInfo2 === void 0 ? void 0 : _this$userInfo2.typeOfLogin // openlogin's login type is subset of torus embed, so it is safe to cast.
        })
      });
    }
  }

  async setChainID(chainId) {
    const sessionConfig = await this.sessionConfig();
    const {
      chainConfig
    } = sessionConfig || {};
    if (chainId !== sessionConfig.chainId && chainConfig) {
      await this.torusWalletInstance.setProvider(_objectSpread(_objectSpread({}, chainConfig), {}, {
        chainId,
        host: chainConfig.rpcTarget,
        networkName: chainConfig.displayName
      }));
    }
  }
}
;// CONCATENATED MODULE: ./src/index.ts

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=torusWalletConnectorPlugin.cjs.js.map